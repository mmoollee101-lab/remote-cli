---
name: manage-skills
description: |
  세션 변경사항을 분석하여 검증 스킬 누락을 탐지합니다.
  기존 스킬을 동적으로 탐색하고, 새 스킬을 생성하거나 기존 스킬을 업데이트한 뒤 CLAUDE.md를 관리합니다.
disable-model-invocation: true
argument-hint: "[선택사항: 특정 스킬 이름 또는 집중할 영역]"
---

# 세션 기반 스킬 유지보수

## 목적

현재 세션에서 변경된 내용을 분석하여 검증 스킬의 드리프트를 탐지하고 수정합니다:

1. **커버리지 누락** — 어떤 verify 스킬에서도 참조하지 않는 변경된 파일
2. **유효하지 않은 참조** — 삭제되거나 이동된 파일을 참조하는 스킬
3. **누락된 검사** — 기존 검사에서 다루지 않는 새로운 패턴/규칙
4. **오래된 값** — 더 이상 일치하지 않는 설정값 또는 탐지 명령어

## 실행 시점

- 새로운 패턴이나 규칙을 도입하는 기능을 구현한 후
- 기존 verify 스킬을 수정하고 일관성을 점검하고 싶을 때
- PR 전에 verify 스킬이 변경된 영역을 커버하는지 확인할 때
- 주기적으로 스킬을 코드베이스 변화에 맞춰 정렬할 때

## 등록된 검증 스킬

현재 프로젝트에 등록된 검증 스킬 목록입니다. 새 스킬 생성/삭제 시 이 목록을 업데이트합니다.

| 스킬 | 경로 | 커버리지 |
|------|------|----------|
| `verify-security` | `.claude/skills/verify-security/SKILL.md` | 인증, Path Traversal, 환경변수, 입력 검증 |
| `verify-process` | `.claude/skills/verify-process/SKILL.md` | 프로세스 스폰, 시그널 핸들링, 동시성, 리소스 정리 |

## 워크플로우

### Step 1: 세션 변경사항 분석

현재 세션에서 변경된 모든 파일을 수집합니다:

```bash
# 커밋되지 않은 변경사항
git diff HEAD --name-only

# 현재 브랜치의 커밋 (main에서 분기된 경우)
git log --oneline main..HEAD 2>/dev/null

# main에서 분기된 이후의 모든 변경사항
git diff main...HEAD --name-only 2>/dev/null
```

중복을 제거한 목록으로 합칩니다.

**표시:** 최상위 디렉토리 기준으로 파일을 그룹화합니다:

```markdown
## 세션 변경사항 감지

**이 세션에서 N개 파일 변경됨:**

| 디렉토리 | 파일 |
|----------|------|
| src/components | `Button.tsx`, `Modal.tsx` |
| src/server | `router.ts`, `handler.ts` |
| tests | `api.test.ts` |
| (루트) | `package.json` |
```

### Step 2: 등록된 스킬과 변경 파일 매핑

위의 **등록된 검증 스킬** 섹션에 나열된 스킬을 참조하여 파일-스킬 매핑을 구축합니다.

등록된 스킬이 0개인 경우, Step 4로 바로 이동합니다.

등록된 스킬이 1개 이상인 경우, 각 스킬의 SKILL.md를 읽고 파일 경로 패턴을 추출합니다.

```markdown
### 파일 → 스킬 매핑

| 스킬 | 트리거 파일 (변경된 파일) | 액션 |
|------|--------------------------|------|
| verify-api | `router.ts`, `handler.ts` | CHECK |
| (스킬 없음) | `package.json` | UNCOVERED |
```

### Step 3: 영향받은 스킬의 커버리지 갭 분석

영향받은 각 스킬에 대해 다음을 점검합니다:

1. **누락된 파일 참조** — 변경 파일이 Related Files에 없는 경우
2. **오래된 탐지 명령어** — 패턴이 현재 파일 구조와 일치하는지
3. **커버되지 않은 새 패턴** — 스킬이 검사하지 않는 새로운 규칙
4. **삭제된 파일의 잔여 참조** — 더 이상 존재하지 않는 파일 참조
5. **변경된 값** — 수정된 파일에서 변경된 설정값

### Step 4: CREATE vs UPDATE 결정

```
커버되지 않은 각 파일 그룹에 대해:
    IF 기존 스킬의 도메인과 관련된 파일인 경우:
        → 결정: 기존 스킬 UPDATE (커버리지 확장)
    ELSE IF 3개 이상의 관련 파일이 공통 규칙/패턴을 공유하는 경우:
        → 결정: 새 verify 스킬 CREATE
    ELSE:
        → "면제"로 표시 (스킬 불필요)
```

`AskUserQuestion`을 사용하여 확인합니다.

### Step 5: 기존 스킬 업데이트

**규칙:**
- **추가/수정만** — 아직 작동하는 기존 검사는 절대 제거하지 않음
- **Related Files** 테이블에 새 파일 경로 추가
- 변경된 파일에서 발견된 패턴에 대한 새 탐지 명령어 추가
- 코드베이스에서 삭제가 확인된 파일의 참조 제거

### Step 6: 새 스킬 생성

새로 생성할 각 스킬에 대해:

1. **탐색** — 관련 변경 파일을 읽어 패턴을 이해합니다

2. **사용자에게 스킬 이름 확인** — `AskUserQuestion` 사용:
   - 이름은 `verify-`로 시작 (예: `verify-auth`, `verify-api`)
   - kebab-case 사용

3. **생성** — `.claude/skills/verify-<name>/SKILL.md` 생성

필수 섹션:
- **Purpose** — 검증 카테고리
- **When to Run** — 트리거 조건
- **Related Files** — 실제 파일 경로 테이블
- **Workflow** — 검사 단계 (도구, 경로, PASS/FAIL 기준)
- **Output Format** — 결과 테이블
- **Exceptions** — 위반이 아닌 케이스

4. **연관 파일 업데이트**:
   - 이 파일의 **등록된 검증 스킬** 테이블에 새 스킬 추가
   - `CLAUDE.md`의 Skills 테이블에 새 스킬 추가

### Step 7: 검증

1. 수정된 모든 SKILL.md 파일 다시 읽기
2. 마크다운 형식 확인
3. Related Files의 각 경로에 대해 파일 존재 확인
4. 탐지 명령어 문법 유효성 검증

### Step 8: 요약 보고서

```markdown
## 세션 스킬 유지보수 보고서

### 분석된 변경 파일: N개

### 업데이트된 스킬: X개
- `verify-<name>`: N개의 새 검사 추가

### 생성된 스킬: Y개
- `verify-<name>`: <패턴> 커버

### 영향없는 스킬: Z개

### 미커버 변경사항 (적용 스킬 없음):
- `path/to/file` — 면제 (사유)
```

## 품질 기준

생성/업데이트된 모든 스킬은 다음을 갖추어야 합니다:

- **코드베이스의 실제 파일 경로** (검증됨)
- **작동하는 탐지 명령어**
- **PASS/FAIL 기준**
- **최소 2-3개의 현실적인 예외**
- **일관된 형식**

## 예외사항

다음은 **문제가 아닙니다**:

1. **Lock 파일 및 생성된 파일** — `package-lock.json`, `yarn.lock` 등
2. **일회성 설정 변경** — 버전 범프, 사소한 린터 설정
3. **문서 파일** — `README.md`, `CHANGELOG.md`, `LICENSE`
4. **테스트 픽스처 파일** — `fixtures/`, `test-data/`
5. **벤더/서드파티 코드** — `vendor/`, `node_modules/`
6. **CI/CD 설정** — `.github/`, `Dockerfile`
